use sys_info;
#[cfg(target_os = "linux")]
use std::fs::File;
#[cfg(target_os = "linux")]
use std::io::{self, BufRead};

#[cfg(target_os = "windows")]
use winapi::um::winbase::{LocalFree, NetUserEnum, NetApiBufferFree};
#[cfg(target_os = "windows")]
use winapi::um::lmaccess::{USER_INFO_0};
#[cfg(target_os = "windows")]
use winapi::shared::lmcons::MAX_PREFERRED_LENGTH;

fn get_user() {
    // Get the current user's name
    let username = whoami::username();

    println!("Current user: {}", username);
}

fn get_system() -> (&'static str, &'static str) {

    // Get operating system and architecture
    let os = std::env::consts::OS;
    let arch = std::env::consts::ARCH;

    println!("Operating System: {}", os);
    println!("Architecture: {}", arch);

    // Get more detailed system information
    match sys_info::os_type() {
        Ok(os_type) => println!("OS Type: {}", os_type),
        Err(e) => eprintln!("Error getting OS type: {}", e),
    }

    match sys_info::os_release() {
        Ok(os_release) => println!("OS Release: {}", os_release),
        Err(e) => eprintln!("Error getting OS release: {}", e),
    }

    match sys_info::cpu_num() {
        Ok(cpu_num) => println!("Number of CPUs: {}", cpu_num),
        Err(e) => eprintln!("Error getting CPU count: {}", e),
    }

    match sys_info::mem_info() {
        Ok(mem_info) => println!("Total Memory: {} KB", mem_info.total),
        Err(e) => eprintln!("Error getting memory info: {}", e),
    }
    // Return the operating system and architecture
    (os, arch)
}

fn list_users(os: &str) {
    match os {
        "linux" => {
            #[cfg(target_os = "linux")]
            {
                let path = "/etc/passwd";
                if let Ok(file) = File::open(path) {
                    let reader = io::BufReader::new(file);
                    for line in reader.lines() {
                        if let Ok(line) = line {
                            if let Some(user) = line.split(':').next() {
                                println!("User: {}", user);
                            }
                        }
                    }
                } else {
                    eprintln!("Error: Could not open {}", path);
                }
            }
        },
        "windows" => {
            #[cfg(target_os = "windows")]
            unsafe {
                let mut buf: *mut USER_INFO_0 = std::ptr::null_mut();
                let mut entries: DWORD = 0;
                let mut total_entries: DWORD = 0;

                let result = NetUserEnum(
                    std::ptr::null_mut(),
                    0,
                    2, // User accounts
                    &mut buf as *mut *mut _ as *mut *mut std::ffi::c_void,
                    MAX_PREFERRED_LENGTH,
                    &mut total_entries,
                    &mut entries,
                    std::ptr::null_mut(),
                );

                if result == 0 {
                    for i in 0..total_entries {
                        let user_info = *(buf.offset(i as isize) as *mut USER_INFO_0);
                        let username = std::ffi::CStr::from_ptr(user_info.usri0_name).to_string_lossy();
                        println!("User: {}", username);
                    }
                    NetApiBufferFree(buf as *mut std::ffi::c_void);
                } else {
                    eprintln!("Error retrieving user list: {}", result);
                }
            }
        },
        _ => {
            eprintln!("Unsupported operating system specified: {}", os);
        }
    }
}

fn main() {
    get_user(); // Current User
    let (os, arch) = get_system(); // Operating system and architecture
    if let Err(e) = list_users(os) { // List all users
        eprintln!("Error listing users: {}", e);
    }

}